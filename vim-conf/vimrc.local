"######################################################################
"#                                                ___
"#                                              /'___\ __
"#  ___ ___   __  __        ___    ___     ___ /\ \__//\_\     __
"#/' __` __`\/\ \/\ \      /'___\ / __`\ /' _ `\ \ ,__\/\ \  /'_ `\
"#/\ \/\ \/\ \ \ \_\ \    /\ \__//\ \L\ \/\ \/\ \ \ \_/\ \ \/\ \L\ \
"#\ \_\ \_\ \_\/`____ \   \ \____\ \____/\ \_\ \_\ \_\  \ \_\ \____ \
"# \/_/\/_/\/_/`/___/> \   \/____/\/___/  \/_/\/_/\/_/   \/_/\/___L\ \
"#                /\___/                                       /\____/
"#                \/__/                                        \_/__/
"#
"######################################################################

"Some Mapping :
map <F1> :bp<cr>
map <F2> :bn<cr>
map <F12> :source ${HOME}/.vimrc.local<cr>

" For no auto-indent :
map <F8> :setl noai nocin nosi inde=<CR>
" For switching tabs with Shit-Tab :
map <S-Tab>  :tabNext<cr>

" to open next occurence of search (git jump grep "something")
map <F10> :cn<cr>

" Better escape :
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr> <Esc> pumvisible() ? "\<C-e>" : "\<Esc>"
iunmap <Esc>

" Regarding folds
set foldmethod=marker
set foldcolumn=2
"setlocal foldnestmax=1
nnoremap <Space> za
vnoremap <Space> za

" Indenting
set shiftwidth=2                " Use indents of 2 spaces
set tabstop=2                   " An indentation every 2 columns
set softtabstop=2               " Let backspace delete indent


"Filetype defaults :
if has("autocmd")
  au BufNewFile,BufRead *.nml set filetype=fortran
  au BufNewFile,BufRead *.namelist set filetype=fortran
  "au BufNewFile,BufRead *.nix set filetype=nix
  "au BufNewFile,BufRead *.sh set filetype=sh
  "au BufNewFile,BufRead *.vimrc* set filetype=vim
  "au BufNewFile,BufRead *.vim set filetype=vim
endif

" Use local vimrc if available {
    if filereadable(expand("~/.vimrc.before.local"))
        source ~/.vimrc.before.local
    endif
" }

syntax on

" Plugins are loaded after .vimrc files, so in case of sourcing .vimrc files
" while vim is being executed, we need to wrap the plugin into a try - endtry
" to avoid error message at vim start.
if exists('g:rainbow_active')
  try
    execute ":RainbowToggleOn"
  catch
  endtry
endif

" About Colors & Themes :
set t_Co=256            " use 256 colors in vim
colorscheme solarized   " an appropriate color scheme

execute ":set background=dark"

"Change Normal colors first
execute ":highlight Normal cterm=NONE ctermfg=DarkGrey ctermbg=NONE"

"Change the color of line number to DarkGrey and the background to wathever
execute ":highlight LineNr cterm=bold ctermfg=DarkGrey ctermbg=NONE"

" Change the highlight of the current line : (well choosed by colorscheme)
"execute ":highlight CursorLine ctermbg=0"

" Change the color of the foldcolumn :
execute ":highlight foldcolumn ctermbg=NONE ctermfg=NONE"


function! BgToggleSol()
  if &background == "light"
    execute ":set background=dark"
    execute ":highlight Normal cterm=NONE ctermfg=DarkGrey ctermbg=NONE"
    execute ":highlight LineNr cterm=bold ctermfg=DarkGrey ctermbg=NONE"
    "execute ":highlight CursorLine ctermbg=0"
    execute ":highlight foldcolumn ctermbg=NONE ctermfg=NONE"
  else
    execute ":set background=light"
    execute ":highlight Normal cterm=NONE ctermfg=DarkGrey ctermbg=230"
    execute ":highlight LineNr cterm=bold"
    "execute ":highlight foldcolumn ctermbg=NONE ctermfg=NONE"
  endif
endfunction
map <F4> :call BgToggleSol()<cr>






" --------------- FUNCTIONS HOME MADE  ------------- "

""{{{

"function! s:get_visual_selection()
"  " Why is this not a built-in Vim script function?!
"  let [lnum1, col1] = getpos("'<")[1:2]
"  let [lnum2, col2] = getpos("'>")[1:2]
"  let lines = getline(lnum1, lnum2)
"  let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
"  let lines[0] = lines[0][col1 - 1:]
"  return join(lines, "\n")
"endfunction"

"function! s:Echo_highlighted_text()
"  let s:highlighted_text = s:get_visual_selection()
"  echo s:highlighted_text
"endfunction

"" --------------- FUNCTIONS HOME MADE  ------------- "
"" Syntax examples {{{1

"" Function to automatize replacing in ctests : {{{
"function! Change_with_macro()
"  "let s:proj_name = s:get_visual_selection()
"  let s:paragraph_to_be_replaced_pattern ="call \\(allocate\\|deallocate\\|realloc\\|axpy\\|scal\\|copy\\)FluidParticlesDt(.*\\zs)\\ze"
"  let s:final_paragraph = ", FLUIDPARTICLESDt_ALL_COMPONENTS)"
"  echo s:paragraph_to_be_replaced_pattern

"  "echo s:paragraph_to_be_replaced_pattern
"  "echo s:final_paragraph

"  "let s:command_substitute = ":%s:".s:paragraph_to_be_replaced_pattern.":".s:final_paragraph."\\r\\r:gc"
"  let s:command_substitute = ":%s:".s:paragraph_to_be_replaced_pattern.":".s:final_paragraph.":gc"
"  execute s:command_substitute
"endfunction
""}}}

"" Function to automatize delete in ctests : {{{
"function! Delete_quick_mode()
"  let s:paragraph_to_be_deleted_pattern ="^set(JOB_NMAX_NUM_DT\\(.*\\n\\)\\{-}endif()\\(\\n\\)*"
"  let s:final_paragraph =""
"  let s:command_substitute = ":%s:".s:paragraph_to_be_deleted_pattern.":".s:final_paragraph."\\r:gc"
"  execute s:command_substitute
"endfunction
""}}}

"" Function to automatize Tabularize in ctests : {{{
"function! Tabularize_autom()
"  let s:command_tabularize_1 = ":/^set(SPH_.*/ Tabularize /^set(SPH_\\w* \\zs\\w*\\ze"
"  execute s:command_tabularize_1

"  let s:command_tabularize_1 = ":/^set(SPH_.*/ Tabularize /^set(SPH_\\w* \\zs\\w*\\ze"
"  execute s:command_tabularize_1

"  let s:command_tabularize_2 = ":/^set(SPH_.*/ Tabularize /^set(SPH_.*\\zs\"\\w.*\\ze"
"  execute s:command_tabularize_2

"  let s:command_tabularize_3 = ":/^set(SPH_.*/ Tabularize /^set(SPH_.*\\zsFORCE\\ze"
"  execute s:command_tabularize_3
"endfunction
""}}}

"" Function to add a pattern : {{{
"function! Add_pattern()
"  "let s:message_patern = s:get_visual_selection()

"  let s:num_curr_line  = line('.')
"  let s:range_command = s:num_curr_line . "," . s:num_curr_line

"  let s:curr_line = getline(s:num_curr_line)

"  let s:pattern_select_member_particles = "enumerator.*::.*FP_\\zs\\w*\\ze\\n"
"  let s:selected_member_particlesDt = matchstr(s:curr_line, s:pattern_select_member_particles)

"  let s:pattern_to_be_replaced = ".*enumerator.*"
"  let s:pattern_to_replace = ", \\'" . s:selected_member_particles . "\\'"
"  let s:command_test = s:range_command . "s:" . s:pattern_to_be_replaced . ":" . s:pattern_to_replace . ":g"
"  execute s:command_test

"  "let s:command_test = s:range_command . "s: \\<.*\\(FPDt[^,]*\\): if(activeVariables(\\1)) &:g"
"  "execute s:command_test

"endfunction
""}}}

"" Function to comment personalized : {{{
"function! Personalized_comment()
"  "let s:message_patern = s:get_visual_selection()

"  let s:num_curr_line  = line('.')
"  let s:range_command = s:num_curr_line . "," . s:num_curr_line

"  let s:command_test = s:range_command . "s:.*:\\! TO DELETE  &:g"
"  execute s:command_test

"endfunction
""}}}
""1}}}

"UseFull functions {{{1

" Function to automatize Tabularize fortran arguments :
function! Tabularize_fortran_subroutine_args()

  "Syntax Sanity checks : {{{2
  "Save position :
  let s:line_pos = line('.')
  let s:col_pos = col('.')

  let s:range_replace = ":\.,'\}"

  " paragraph range = '{,'}
  let s:replace_for_coma_sanity = s:range_replace." s: *,:,:g"
  execute s:replace_for_coma_sanity

  execute ":normal! ".s:line_pos."G"

  let s:replace_for_parenthesis_sanity = s:range_replace." s: *(:(:g"
  execute s:replace_for_parenthesis_sanity
  execute ":normal! ".s:line_pos."G"

"2}}}

  " For Final Indentation : {{{2

  "let s:range_tabularize = ":/\.\*intent\.\*::/"
  let s:range_tabularize = ":\.,'\}"

  let s:integer_syntax = "\\(integer *(.\\{-})\\|integer\\)"
  let s:real_syntax = "\\(real *(.\\{-})\\|real\\)"
  let s:character_syntax = "\\(character *(.\\{-})\\|character\\)"
  let s:logical_syntax = "\\(logical *(.\\{-})\\|logical\\)"
  let s:derived_type_syntax = "\\(type *(.\\{-})\\)"

  let s:every_type_syntax = "\\(".s:integer_syntax."\\|".s:real_syntax."\\|".s:character_syntax."\\|".s:logical_syntax."\\|".s:derived_type_syntax."\\)"
  let s:command_tabularize_types = s:range_tabularize." Tabularize /^ *\\zs".s:every_type_syntax.",\\ze"
  execute s:command_tabularize_types

  execute ":normal! ".s:line_pos."G"

  "let s:dimension_syntax = "dimension *(.\\{-})"
  "let s:command_tabularize_dimension = s:range_tabularize." Tabularize /\\zs".s:dimension_syntax.",\\ze"
  "execute s:command_tabularize_dimension

  "execute ":normal! ".s:line_pos."G"

  "let s:optional_syntax = "optional"
  "let s:command_tabularize_optional = s:range_tabularize." Tabularize /\\zs".s:optional_syntax.",\\ze"
  "execute s:command_tabularize_optional

  execute ":normal! ".s:line_pos."G"

  let s:intent_syntax = "intent *(.\\{-})"
  let s:command_tabularize_intent = s:range_tabularize." Tabularize /.*\\zs".s:intent_syntax."\\ze"
  execute s:command_tabularize_intent

  execute ":normal! ".s:line_pos."G"

  let s:command_tabularize_double_dot = s:range_tabularize." Tabularize /\\zs::\\ze"
  execute s:command_tabularize_double_dot

  execute ":normal! ".s:line_pos."G"
"2}}}

endfunction
"1}}}
map <F5> :silent! :call Tabularize_fortran_subroutine_args()<cr>

" Execute 'cmd' while redirecting output.
" Delete all lines that do not match regex 'filter' (if not empty).
" Delete any blank lines.
" Delete '<whitespace><number>:<whitespace>' from start of each line.
" Display result in a scratch buffer.
"
function! s:Filter_lines(cmd, filter)
  let save_more = &more
  set nomore
  redir => lines
  silent execute a:cmd
  redir END
  let &more = save_more
  new
  setlocal buftype=nofile bufhidden=hide noswapfile
  put =lines
  g/^\s*$/d
  %s/^\s*\d\+:\s*//e
  if !empty(a:filter)
    execute 'v/' . a:filter . '/d'
  endif
  0
endfunction
command! -nargs=? Scriptnames call s:Filter_lines('scriptnames', <q-args>)
command! -nargs=? Syntaxlist call s:Filter_lines('syntax list', <q-args>)
command! -nargs=? VerboseHighlight call s:Filter_lines('verbose highlight', <q-args>)
